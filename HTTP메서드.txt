초보 개발자가 API URI 설계를 한다면?
    ->  회원 목록 조회 / read-member-list
        회원 조회 / read-member-by-id
        회원 등록 / create-n member
        회원 수정 / update-member
        회원 삭제 / delete-member
    
과연 좋은 URI설계인가 ( 제일 중요한건 '리소스 식별' )
    ->  리소스의 의미는 뭘까
        ->  회원을 등록하고 수정하고 조회하는게 리소스가 아니다.
            -> ex ) 미네랄을 캐라 -> 미네랄이 리소스
            ->  회원이라는 개념 자체가 바로 리소스다 !
    -> 리소스를 어떻게 식별하면 좋을까
        ->  회원을 등록하고 수정하고 조회하는것을 모두 배제
        ->  회원이라는 리소스만 식별하면 된다, -> 회원 리소스를 URI에 매핑

다시 설계해보자
    ->  회원 목록 조회 /members
        회원 조회 /member/{id}  -> 회원이 리소스인건 알겠는데 어떻게 구분하지????
        회원 등록 /member/{id}  -> 회원이 리소스인건 알겠는데 어떻게 구분하지????  
        회원 수정 /member/{id}  -> 회원이 리소스인건 알겠는데 어떻게 구분하지????
        회원 삭제 /member/{id}  -> 회원이 리소스인건 알겠는데 어떻게 구분하지????

URI는 리소스만 식별한다, ( 가장 중요한 것은 리소스를 식별하는 것)
    ->  리소스와 해당 리소스를 대상으로 하는 행위를 분리
        ->  리소스 : 회원
        ->  행위 : 조회, 등록, 삭제, 변경
    리소스는 명사, 행위는 동사
    행위(메서드)는 어떻게 구분하나~.....

HTTP 메서드 - GET, POST / HTTP메서드는 클라이언트가 서버한테 요청을할때 기대하는 행동
    ->  GET    : 리소스 조회
        POST   : 요청 데이터 처리, 주로 등록에 사용
        PUT    : 리소스를 대체, 해당 리소스가 없으면 생성
        PATCH  : 리소스 부분변경
        DELETE : 리소스 삭제

        기타 메서드 
            HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태줄과 헤더만 반환
            OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로CORS에서 사용)
            CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
            TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

    GET 
        ->  리소스 조회
            서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리스트링)를 통해서 전달
            메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지않음.
                                                        서버 : /members/100 
            GET /members/100 HTTP/1.1                  { "username":"young",
            Host: localhost:8080                          "age":20 }

    POST
        ->  요청 데이터 처리
            메시지 바디를 통해 서버로 요청데이터 전달
            서버는 요청데이터를 처리
                ->매시지 바디를 통해 등러온 데이터를 처리하는 모든 기능을 수행
            주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

            POST /members HTTP/1.1                                         /members      //클라이언트와 서버는 미리 약속을 해놓는다  "클라이언트야 /members 에 POST를 보내면 그건 내가 저장하거나, 내부 프로세스에 쓸게~"
            Content-Type: application/json         -> POST요청 ->          /members/100  -신규 리소스 식별자'100'을 생성
                                                                            {
            {                                                                   "username": "young"
                "username":"young",                                             "age": 20
                "age":20                                                    }
            }
            
        근데 POST는 요청 데이터를 어떻게 처리한다는 건데..
            -> POST 스펙 : POST메서드는 대상 리소스가 리소스 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청합니다
            쉽게 예제로 살펴보면
                -   HTML양식에 입력된 필드와 같은 데이터 블록을 데이터 처리프로세스에 제공
                        ex) HTML FORM에 입력한 정보로 회원가입, 주문등에서 사용
                    게시판, 뉴스그룹, 블로그
                        ex) 게시판 글쓰기, 댓글 달기
                    서버가 아직 식별하지 않은 새 리소스 생성
                        ex) members/100, 신규 주문생성
                    기존 자원에 데이터 추가
            정리 : 이 리소스 URI에 POST요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야함 -> 정해진것이없다.
                ->  새 리소스 생성(등록)
                ->  요청 데이터 처리
                    단순 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는경우
                        ex) 주문에서 결제완료-> 배달시작 -> 배달완료 처럼 값변경을 넘어 프로세스의 상태가 변경되는 경우
                    POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
                        ex) POST /orders/{orderId}/start-delivery(최대한 리소스 URI로 설계하되 어쩔수없는 애매한건 컨트롤 URI사용 -동사URI)
                -> 다른 메서드로 처리하기 애매한 경우
                        ex) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운경우 (GET메서드를 지원하지 않는 서버들이 많아서 POST의 Body부분에 데이터를 담아서  넘긴다.)
                        애매하면 POST /메시지를 담아서 보내는 모든행위가능 단, 조회 데이터는 GET을 쓰는게 유리하다(캐싱때문), 데이터 변경, 프로세스의 진행은 POST를 쓰도록하자
                
                POST는 "무적"이다.

    PUT
        ->  리소스를 대체
                리소스가 있으면 대체
                리소스가 없으면 생성
                쉽게 이야기해서 덮어버림
            중요! 클라이언트가 리소스를 식별
                클라이언트가 리소스 위치를 알고 URI 지정(/member/100)
                POST와 차이점

        클라이언트 
        PUT /members/100 HTTP/1.1
            Content-Type: application/json

            {
                "username": "hello",
                "age": 20
            }
        
        -> 서버로 전송 (데이터가 없는경우)

        서버 : /member/100
            {
                "username": "hello",
                "age": 20
            }

        -> 주의!!! 리소스를 완전히 대체!!! - 1

             ??? : "아 나이 잘못적었네 다시 보내야지~"
        PUT /members/100 HTTP/1.1
            Content-Type: application/json

            {
                "age": 50
            }

        -> 서버로 전송
        
        서버 : /member/100
            {
                "age": 50,
            }

            -> username 필드가 없어짐 ,,,,,,

        PUT은 리소스를 고쳐쓰는게 아니다!! 이런 경우엔 PATCH를 사용하자!
    
    PATCH
        리소스 부분변경

            PATCH /members/100 HTTP/1.1
            Content-Type: application/json

            {
                "age": 50
            }

            -> 서버로 보내면~

            서버 : /member/100
            {
                "username": "hello"
                "age": 50,
            }
                나이만 바뀌었네 굿~

                PATCH가 지원안되는 서버의 경우에는 어떡하지..
                    ->POST를 쓰면된다 기억하자 POST는 "무적"이다. POST는 "무적"이다. POST는 "무적"이다. POST는 "무적"이다. POST는 "무적"이다.
                    POST는 "무적"이다.POST는 "무적"이다.POST는 "무적"이다.POST는 "무적"이다.POST는 "무적"이다.POST는 "무적"이다.
                    POST는 "무적"이다.POST는 "무적"이다.POST는 "무적"이다.POST는 "무적"이다.

    DELETE
        리소스 제거
            DELETE /members/100 HTTP/1.1
            Host: localhost:8080

            ->  members/100이 제거된다~


    HTTP 메서드의 속성
        ->  안전
            ->  호출해도 리소스를 변경하지않는다!
                ???  : 그래도 계속 호출해서, 로그 쌓여서 장애나면??
                안전 : 내 알빠아님, 
                    ->  안전은 해당 리소스가 변하냐 변하지않냐만 고려한다. 그런 부분까지 고려하지 않는다
        ->  멱등
            ->  f(f(x)) = (f(fx))
                한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다.
                멱등 메서드
                    GET 한번 조회하든 두번 조회하든 같다
                    PUT 결과를 대체한다, 여러번해도 최종결과가 같다
                    DELETE 같은 요청을 요러번해도 삭제된 결과는 똑같다.
                    ※POST : 멱등하지 않다. ex) 결제가 두번되면?..결제가 두번되면?..결제가 두번되면?..결제가 두번되면?..결제가 두번되면?.. 
                활용
                    자동 복구 메커니즘
                    서버가 TIMEOUT등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도되는가? 의 판단근거가 됨

                ???: "재요청 중간에 다른곳에서 리소스가 바뀌면 어떡해요"
                    ex) 사용자1 : GET -> username: A , age:20
                        사용자2 : PUT -> username: A , age:30
                        사용자3 : GET -> username: A , age:30 ->사용자2의 영향으로 바뀐 데이터 조회
                    멱등 : 외부요인으로 중간에 리소스가 변경되는 것 까지는 고려하지않는다. 
                    //이런건 멱등하지 않다고 판단하고, PUT으로 중간에 바뀌는 부분들은 서버에서 '어 중간에 버전이 바뀌었네;' 라고 체크해줘야 한다.

        ->  캐시가능
            ->  응답 결과 리소스를 캐시해서 사용해도 되는가?
                GET, HEAD, POST, PATCH 캐시가능 /GET은 URL을 Key값으로해서 캐싱하면되지만 POST,PATCH는 본문내용까지 캐시 키로 고려해야하는데 사용하기 어렵다.
                실제로는 GET, HEAD 정도만 캐시로 사용
                    POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음
                



    




        

